<html>
<head>
<title>irls.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c4;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
irls.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">{ 
 &quot;cells&quot;: [ 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 7, 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: true, 
    &quot;pycharm&quot;: { 
     &quot;is_executing&quot;: false 
    } 
   }, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;import numpy as np\n&quot;, 
    &quot;import pandas as pd\n&quot;, 
    &quot;import matplotlib.pyplot as plt\n&quot;, 
    &quot;df = pd.read_csv(r\&quot;C:\\Users\\Kostas\\Documents\\αναγνώριση προτύπων\\MLR.data\&quot;,header=None, sep=' ')\n&quot;, 
    &quot;X = df.to_numpy()\n&quot;, 
    &quot;y = X[:,-1]\n&quot;, 
    &quot;X = X[:,:-1]&quot; 
   ] 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 8, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;class Logistic_Model():\n&quot;, 
    &quot;\tdef __init__(self,X,y):\n&quot;, 
    &quot;\t\tself.X = X\n&quot;, 
    &quot;\t\tself.y = y\n&quot;, 
    &quot;\t\tself.classes = np.unique(y).shape[0]\n&quot;, 
    &quot;\t\tself.dim = self.X.shape[1]\n&quot;, 
    &quot;\t\tself.MAX_ITERATIONS = 30\n&quot;, 
    &quot;\t\tself.t = self.construct_targets()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\tdef construct_targets(self):\n&quot;, 
    &quot;\t\tt = np.zeros((self.y.shape[0],self.classes))\n&quot;, 
    &quot;\t\tfor i in range(self.y.shape[0]):\n&quot;, 
    &quot;\t\t\tt[i,int(self.y[i])] = 1\n&quot;, 
    &quot;\t\treturn t\n&quot;, 
    &quot;\n&quot;, 
    &quot;\tdef train(self):\n&quot;, 
    &quot;\t\t# initialize before iterative procedure\n&quot;, 
    &quot;\t\tw_new = np.random.random((self.classes,self.dim))\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\tfor i in range(self.MAX_ITERATIONS):\n&quot;, 
    &quot;\t\t\tself.w = w_new\n&quot;, 
    &quot;\t\t\t# calculate output - y_nk\n&quot;, 
    &quot;\t\t\tself.y_hat = self.softmax()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\t\t# calculate metrics\n&quot;, 
    &quot;\t\t\tself.success_rate = np.where(np.argmax(self.y_hat, axis=0) - self.y == 0)[0].size/self.y.shape[0]\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\t\t# calculate derivative vector K x D\n&quot;, 
    &quot;\t\t\tE = self.derivative()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\t\t# calculate hessian matrix - K x K\n&quot;, 
    &quot;\t\t\tH = self.hessian()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\t\t# update weights\n&quot;, 
    &quot;\t\t\ttry:\n&quot;, 
    &quot;\t\t\t\tw_new = self.w + np.matmul(np.linalg.inv(H),E)\n&quot;, 
    &quot;\t\t\texcept np.linalg.LinAlgError:\n&quot;, 
    &quot;\t\t\t\tprint('Singular Matrix, using another initial weighting matrix..')\n&quot;, 
    &quot;\t\t\t\tw_new = np.random.random((self.classes, self.dim))\n&quot;, 
    &quot;\n&quot;, 
    &quot;\t\tself.w = w_new\n&quot;, 
    &quot;\t\tpass\n&quot;, 
    &quot;\n&quot;, 
    &quot;\tdef hessian(self):\n&quot;, 
    &quot;\t\tres = np.empty((self.classes,self.classes))\n&quot;, 
    &quot;\t\tidentity = np.diag(np.ones(self.classes))\n&quot;, 
    &quot;\t\tfor i in range(self.classes):\n&quot;, 
    &quot;\t\t\tfor j in range(self.classes):\n&quot;, 
    &quot;\t\t\t\ttmp = self.y_hat[i,:]*(identity[i,j] - self.y_hat[j,:])*np.sum(np.square(self.X), axis=1)\n&quot;, 
    &quot;\t\t\t\ttmp = - np.sum(tmp)\n&quot;, 
    &quot;\t\t\t\tres[i,j] = tmp\n&quot;, 
    &quot;\t\treturn res\n&quot;, 
    &quot;\n&quot;, 
    &quot;\tdef derivative(self):\n&quot;, 
    &quot;\t\t# self.y_hat 3 x N\n&quot;, 
    &quot;\t\tres = np.empty((self.classes,self.dim))\n&quot;, 
    &quot;\t\tfor i in range(self.classes):\n&quot;, 
    &quot;\t\t\t# tmp -- 1 x N\n&quot;, 
    &quot;\t\t\ttmp = self.y_hat[i,:] - self.t[:,i]\n&quot;, 
    &quot;\t\t\t# tmp N x 2\n&quot;, 
    &quot;\t\t\ttmp = tmp.reshape(-1,1)*self.X\n&quot;, 
    &quot;\t\t\t# tmp - 2 x 1\n&quot;, 
    &quot;\t\t\ttmp = np.sum(tmp, axis = 0)\n&quot;, 
    &quot;\t\t\tres[i,:] = tmp\n&quot;, 
    &quot;\t\treturn res\n&quot;, 
    &quot;\n&quot;, 
    &quot;\tdef softmax(self, x = None):\n&quot;, 
    &quot;\t\t# w is 3 x 2\n&quot;, 
    &quot;\t\t# x is n x 2\n&quot;, 
    &quot;\t\tif x is None:\n&quot;, 
    &quot;\t\t\ttmp = np.exp(np.matmul(self.w,np.transpose(self.X)))\n&quot;, 
    &quot;\t\t\tsumation = np.sum(tmp, axis=0)\n&quot;, 
    &quot;\t\t\tsumation[sumation &gt; 1e+16] =1e+16\n&quot;, 
    &quot;\t\t\tsumation[sumation &lt; 1e-6] = 1e-6\n&quot;, 
    &quot;\t\t\ttmp = tmp/sumation\n&quot;, 
    &quot;\t\telse:\n&quot;, 
    &quot;\t\t\ttmp = np.exp(np.matmul(self.w, x))\n&quot;, 
    &quot;\t\t\tsumation = np.sum(tmp, axis=0)\n&quot;, 
    &quot;\t\t\tsumation[sumation &gt; 1e+16] =1e+16\n&quot;, 
    &quot;\t\t\tsumation[sumation &lt; 1e-6] = 1e-6\n&quot;, 
    &quot;\t\t\ttmp = tmp /sumation\n&quot;, 
    &quot;\t\treturn tmp\n&quot;, 
    &quot;\tdef predict(self, x):\n&quot;, 
    &quot;\t\treturn np.argmax(self.softmax(x), axis=0)\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot;, 
     &quot;is_executing&quot;: false 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 9, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;class Linear_Model():\n&quot;, 
    &quot;\tdef __init__(self,X,y):\n&quot;, 
    &quot;\t\tself.X = X\n&quot;, 
    &quot;\t\tself.y = y\n&quot;, 
    &quot;\t\tself.classes = np.unique(y).shape[0]\n&quot;, 
    &quot;\t\tself.MAX_ITERATIONS = 30\n&quot;, 
    &quot;\t\tself.t = self.construct_targets()\n&quot;, 
    &quot;\tdef construct_targets(self):\n&quot;, 
    &quot;\t\tt = np.zeros((self.y.shape[0],self.classes))\n&quot;, 
    &quot;\t\tfor i in range(self.y.shape[0]):\n&quot;, 
    &quot;\t\t\tt[i,int(self.y[i])] = 1\n&quot;, 
    &quot;\t\treturn t\n&quot;, 
    &quot;\tdef train(self):\n&quot;, 
    &quot;\t\ttmp = np.matmul(np.transpose(self.X),self.X)\n&quot;, 
    &quot;\t\ttmp = np.matmul(np.linalg.inv(tmp),np.transpose(X))\n&quot;, 
    &quot;\t\ttmp = np.matmul(tmp,self.t)\n&quot;, 
    &quot;\t\tself.w = tmp\n&quot;, 
    &quot;\t\treturn\n&quot;, 
    &quot;\tdef predict(self, x):\n&quot;, 
    &quot;\t\ttmp = np.matmul(np.transpose(self.w), x)\n&quot;, 
    &quot;\t\treturn np.argmax(tmp)\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot;, 
     &quot;is_executing&quot;: false 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 10, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;ml = Linear_Model(X,y)\n&quot;, 
    &quot;ml.train()\n&quot;, 
    &quot;\n&quot;, 
    &quot;m = Logistic_Model(X, y)\n&quot;, 
    &quot;m.train()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot;, 
     &quot;is_executing&quot;: false 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 11, 
   &quot;outputs&quot;: [ 
    { 
     &quot;data&quot;: { 
      &quot;text/plain&quot;: &quot;&lt;Figure size 432x288 with 1 Axes&gt;&quot;, 
      &quot;image/png&quot;: &quot;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\n&quot; 
     }, 
     &quot;metadata&quot;: { 
      &quot;needs_background&quot;: &quot;light&quot; 
     }, 
     &quot;output_type&quot;: &quot;display_data&quot; 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;# meshgrid\n&quot;, 
    &quot;u1, l1 = max(X[:,0]), min(X[:,0])\n&quot;, 
    &quot;u2, l2 = max(X[:,1]), min(X[:,1])\n&quot;, 
    &quot;\n&quot;, 
    &quot;x1 = np.linspace(l1,u1,50)\n&quot;, 
    &quot;x2 = np.linspace(l2,u2,50)\n&quot;, 
    &quot;xv, yv = np.meshgrid(x1, x2)\n&quot;, 
    &quot;xv, yv = xv.reshape(-1,1), yv.reshape(-1,1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;fig = plt.figure()\n&quot;, 
    &quot;col = ['r', 'c', 'g']\n&quot;, 
    &quot;for i in range(xv.shape[0]):\n&quot;, 
    &quot;\ttmp = m.predict(np.array([xv[i],yv[i]]))\n&quot;, 
    &quot;\tplt.scatter(xv[i], yv[i], c= col[tmp[0]])\n&quot;, 
    &quot;plt.show()\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot;, 
     &quot;is_executing&quot;: false 
    } 
   } 
  } 
 ], 
 &quot;metadata&quot;: { 
  &quot;kernelspec&quot;: { 
   &quot;display_name&quot;: &quot;Python 3&quot;, 
   &quot;language&quot;: &quot;python&quot;, 
   &quot;name&quot;: &quot;python3&quot; 
  }, 
  &quot;language_info&quot;: { 
   &quot;codemirror_mode&quot;: { 
    &quot;name&quot;: &quot;ipython&quot;, 
    &quot;version&quot;: 2 
   }, 
   &quot;file_extension&quot;: &quot;.py&quot;, 
   &quot;mimetype&quot;: &quot;text/x-python&quot;, 
   &quot;name&quot;: &quot;python&quot;, 
   &quot;nbconvert_exporter&quot;: &quot;python&quot;, 
   &quot;pygments_lexer&quot;: &quot;ipython2&quot;, 
   &quot;version&quot;: &quot;2.7.6&quot; 
  }, 
  &quot;pycharm&quot;: { 
   &quot;stem_cell&quot;: { 
    &quot;cell_type&quot;: &quot;raw&quot;, 
    &quot;source&quot;: [], 
    &quot;metadata&quot;: { 
     &quot;collapsed&quot;: false 
    } 
   } 
  } 
 }, 
 &quot;nbformat&quot;: 4, 
 &quot;nbformat_minor&quot;: 0 
}</span></pre>
</body>
</html>