<html>
<head>
<title>main.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #c679dd;}
.s1 { color: #a9b7c4;}
.s2 { color: #98c476;}
.s3 { color: #d2945d;}
.s4 { color: #59626f; font-style: italic;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
main.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
<span class="s1">df = pd.read_csv(</span><span class="s2">r&quot;C:\Users\Kostas\Documents\αναγνώριση προτύπων\MLR.data&quot;</span><span class="s1">,header=</span><span class="s0">None</span><span class="s1">, sep=</span><span class="s2">' '</span><span class="s1">)</span>
<span class="s1">X = df.to_numpy()</span>
<span class="s1">y = X[:,-</span><span class="s3">1</span><span class="s1">]</span>
<span class="s1">X = X[:,:-</span><span class="s3">1</span><span class="s1">]</span>
<span class="s0">class </span><span class="s1">Logistic_Model():</span>
	<span class="s0">def </span><span class="s1">__init__(self,X,y):</span>
		<span class="s1">self.X = X</span>
		<span class="s1">self.y = y</span>
		<span class="s1">self.classes = np.unique(y).shape[</span><span class="s3">0</span><span class="s1">]</span>
		<span class="s1">self.dim = self.X.shape[</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s1">self.MAX_ITERATIONS = </span><span class="s3">30</span>
		<span class="s1">self.t = self.construct_targets()</span>

	<span class="s0">def </span><span class="s1">construct_targets(self):</span>
		<span class="s1">t = np.zeros((self.y.shape[</span><span class="s3">0</span><span class="s1">],self.classes))</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.y.shape[</span><span class="s3">0</span><span class="s1">]):</span>
			<span class="s1">t[i,int(self.y[i])] = </span><span class="s3">1</span>
		<span class="s0">return </span><span class="s1">t</span>

	<span class="s0">def </span><span class="s1">train(self):</span>
		<span class="s4"># initialize before iterative procedure</span>
		<span class="s1">w_new = np.random.random((self.classes,self.dim))</span>

		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.MAX_ITERATIONS):</span>
			<span class="s1">self.w = w_new</span>
			<span class="s4"># calculate output - y_nk</span>
			<span class="s1">self.y_hat = self.softmax()</span>

			<span class="s4"># calculate metrics</span>
			<span class="s1">self.success_rate = np.where(np.argmax(self.y_hat, axis=</span><span class="s3">0</span><span class="s1">) - self.y == </span><span class="s3">0</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].size/self.y.shape[</span><span class="s3">0</span><span class="s1">]</span>

			<span class="s4"># calculate derivative vector K x D</span>
			<span class="s1">E = self.derivative()</span>

			<span class="s4"># calculate hessian matrix - K x K</span>
			<span class="s1">H = self.hessian()</span>

			<span class="s4"># update weights</span>
			<span class="s0">try</span><span class="s1">:</span>
				<span class="s1">w_new = self.w + np.matmul(np.linalg.inv(H),E)</span>
			<span class="s0">except </span><span class="s1">np.linalg.LinAlgError:</span>
				<span class="s1">print(</span><span class="s2">'Singular Matrix, using another initial weighting matrix..'</span><span class="s1">)</span>
				<span class="s1">w_new = np.random.random((self.classes, self.dim))</span>

		<span class="s1">self.w = w_new</span>
		<span class="s0">pass</span>

	<span class="s0">def </span><span class="s1">hessian(self):</span>
		<span class="s1">res = np.empty((self.classes,self.classes))</span>
		<span class="s1">identity = np.diag(np.ones(self.classes))</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.classes):</span>
			<span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(self.classes):</span>
				<span class="s1">tmp = self.y_hat[i,:]*(identity[i,j] - self.y_hat[j,:])*np.sum(np.square(self.X), axis=</span><span class="s3">1</span><span class="s1">)</span>
				<span class="s1">tmp = - np.sum(tmp)</span>
				<span class="s1">res[i,j] = tmp</span>
		<span class="s0">return </span><span class="s1">res</span>

	<span class="s0">def </span><span class="s1">derivative(self):</span>
		<span class="s4"># self.y_hat 3 x N</span>
		<span class="s1">res = np.empty((self.classes,self.dim))</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.classes):</span>
			<span class="s4"># tmp -- 1 x N</span>
			<span class="s1">tmp = self.y_hat[i,:] - self.t[:,i]</span>
			<span class="s4"># tmp N x 2</span>
			<span class="s1">tmp = tmp.reshape(-</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">)*self.X</span>
			<span class="s4"># tmp - 2 x 1</span>
			<span class="s1">tmp = np.sum(tmp, axis = </span><span class="s3">0</span><span class="s1">)</span>
			<span class="s1">res[i,:] = tmp</span>
		<span class="s0">return </span><span class="s1">res</span>

	<span class="s0">def </span><span class="s1">softmax(self, x = </span><span class="s0">None</span><span class="s1">):</span>
		<span class="s4"># w is 3 x 2</span>
		<span class="s4"># x is n x 2</span>
		<span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:</span>
			<span class="s1">tmp = np.exp(np.matmul(self.w,np.transpose(self.X)))</span>
			<span class="s1">sumation = np.sum(tmp, axis=</span><span class="s3">0</span><span class="s1">)</span>
			<span class="s1">sumation[sumation &gt; </span><span class="s3">1e+16</span><span class="s1">] =</span><span class="s3">1e+16</span>
			<span class="s1">sumation[sumation &lt; </span><span class="s3">1e-6</span><span class="s1">] = </span><span class="s3">1e-6</span>
			<span class="s1">tmp = tmp/sumation</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">tmp = np.exp(np.matmul(self.w, x))</span>
			<span class="s1">sumation = np.sum(tmp, axis=</span><span class="s3">0</span><span class="s1">)</span>
			<span class="s1">sumation[sumation &gt; </span><span class="s3">1e+16</span><span class="s1">] =</span><span class="s3">1e+16</span>
			<span class="s1">sumation[sumation &lt; </span><span class="s3">1e-6</span><span class="s1">] = </span><span class="s3">1e-6</span>
			<span class="s1">tmp = tmp /sumation</span>
		<span class="s0">return </span><span class="s1">tmp</span>

	<span class="s0">def </span><span class="s1">predict(self, x):</span>
		<span class="s0">return </span><span class="s1">np.argmax(self.softmax(x), axis=</span><span class="s3">0</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">Linear_Model():</span>
	<span class="s0">def </span><span class="s1">__init__(self,X,y):</span>
		<span class="s1">self.X = X</span>
		<span class="s1">self.y = y</span>
		<span class="s1">self.classes = np.unique(y).shape[</span><span class="s3">0</span><span class="s1">]</span>
		<span class="s1">self.MAX_ITERATIONS = </span><span class="s3">30</span>
		<span class="s1">self.t = self.construct_targets()</span>
	<span class="s0">def </span><span class="s1">construct_targets(self):</span>
		<span class="s1">t = np.zeros((self.y.shape[</span><span class="s3">0</span><span class="s1">],self.classes))</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.y.shape[</span><span class="s3">0</span><span class="s1">]):</span>
			<span class="s1">t[i,int(self.y[i])] = </span><span class="s3">1</span>
		<span class="s0">return </span><span class="s1">t</span>
	<span class="s0">def </span><span class="s1">train(self):</span>
		<span class="s1">tmp = np.matmul(np.transpose(self.X),self.X)</span>
		<span class="s1">tmp = np.matmul(np.linalg.inv(tmp),np.transpose(X))</span>
		<span class="s1">tmp = np.matmul(tmp,self.t)</span>
		<span class="s1">self.w = tmp</span>
		<span class="s0">return</span>
	<span class="s0">def </span><span class="s1">predict(self, x):</span>
		<span class="s1">tmp = np.matmul(np.transpose(self.w), x)</span>
		<span class="s0">return </span><span class="s1">np.argmax(tmp)</span>
<span class="s1">ml = Linear_Model(X,y)</span>
<span class="s1">ml.train()</span>

<span class="s1">m = Logistic_Model(X, y)</span>
<span class="s1">m.train()</span>

<span class="s4"># meshgrid</span>
<span class="s1">u1, l1 = max(X[:,</span><span class="s3">0</span><span class="s1">]), min(X[:,</span><span class="s3">0</span><span class="s1">])</span>
<span class="s1">u2, l2 = max(X[:,</span><span class="s3">1</span><span class="s1">]), min(X[:,</span><span class="s3">1</span><span class="s1">])</span>

<span class="s1">x1 = np.linspace(l1,u1,</span><span class="s3">50</span><span class="s1">)</span>
<span class="s1">x2 = np.linspace(l2,u2,</span><span class="s3">50</span><span class="s1">)</span>
<span class="s1">xv, yv = np.meshgrid(x1, x2)</span>
<span class="s1">xv, yv = xv.reshape(-</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">), yv.reshape(-</span><span class="s3">1</span><span class="s1">,</span><span class="s3">1</span><span class="s1">)</span>

<span class="s1">fig = plt.figure()</span>
<span class="s1">col = [</span><span class="s2">'r'</span><span class="s1">, </span><span class="s2">'c'</span><span class="s1">, </span><span class="s2">'g'</span><span class="s1">]</span>
<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(xv.shape[</span><span class="s3">0</span><span class="s1">]):</span>
	<span class="s1">tmp = m.predict(np.array([xv[i],yv[i]]))</span>
	<span class="s1">plt.scatter(xv[i], yv[i], c= col[tmp[</span><span class="s3">0</span><span class="s1">]])</span>
<span class="s1">plt.show()</span>

<span class="s1">fig2 = plt.figure()</span>
<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(y.shape[</span><span class="s3">0</span><span class="s1">]):</span>
	<span class="s1">plt.scatter(X[i,</span><span class="s3">0</span><span class="s1">],X[i,</span><span class="s3">1</span><span class="s1">], c= col[int(y[i])])</span>
<span class="s1">plt.show()</span>

<span class="s4">#fig3 = plt.figure()</span>
<span class="s4">#for i in range(xv.shape[0]):</span>
<span class="s4">#   tmp = ml.predict(np.array([xv[i],yv[i]]))</span>
<span class="s4">#   plt.scatter(xv[i], yv[i], c= col[tmp])</span>
<span class="s4">#plt.show()</span></pre>
</body>
</html>